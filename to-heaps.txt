todo: copy to my dropbox

can put notes i gather from the web on my iPad more easily here,
just use the web interface from github


forums:
https://community.heaps.io/t/the-path-from-flashpunk-to-haxepunk-to-heaps-punk/849/16


heaps structure:

file / package stucture:
  - super terse to reduce typing package names?.. or maybe a linux user thing
h2d
  - **col, collider**
  - filter, 2d shader effects
  - domkit, ?
  - impl, implementation, used internally
  - **(root), most stuff goes here**
h3d
  - ...one day...
hxd
  - shared between both 2d and 3d parts
  - x/clipper
  - x/earcut
  - fmt, ?
  - fs, file-system
  - impl, implementation, used internally, mostly data structures
  - **net, network**
  - poly2tri, polygon2triangle? graphics vertex drawing stuff, **Point** (use this??), Triangle, Edge, etc.
  - **res, resource**
  - **snd, sound**
  - **(root), most stuff goes here**, mostly OS stuff like input, low-level output, Window, etc.; not game-related
(root), ?

class / data stucture:

window, scene, app:
Window[.js/hl/.etc]
  - maybe a high-level abstraction of the OS window (SDL)
  - there's a different Window for every target
  - contains a single static instance of itself: Window.getInstance()
  - generally don't need to touch this, as Scene handles 'n abstracts most of it (??)
  - might be able to edit some vars through the hxml file: for example, Window.title
  - from FP/HXP, this is HXP.Window
  - from Godot/Unity, this is where you check-mark full-screen, borderless, etc. (DisplayMode)
Scene
  - extends Layers and  InteractableScene (??)
    - logic-wise this is quite confusing, but functionality-wise it makes sense:
    - it contains the same functionality of Layers: it maitains an array of Objects ordered from back to front (index 0-n)
  - this data structure is the largest and handles a lot of stuff
  - edits the Window for different ScaleMode
  - draws the entire scene tree front-to-back via render() and drawContent()
  - can add/remove cameras
  - has an interactiveCamera which is the one used to handle mouse/touch input through Interactive
  - provides getInteractive, which might be used by Interactive (??)
  - propogates input events through add/removeEventListener
  - handles changing Scene (?? or in App?)
  - from FP/HXP, maybe a combo of HXP.scene, HXP.screen (ScaleMode, mouse/touch input), and FP/HXP.world
App
  - designed to be inherited, providing entry to the main init() and main update()
  - contains a single static instance of itself (can store a reference of it yourself)
  - has the first default instance of Scene (s2d/s3d)
  - has the main game loop (it's internal, no need to touch)
  - initalizes Key
  - from FP/HXP, this is HXP.Engine (and deprecated HXP.App)
Key
  - a static helper class for key inputs
  - although called "keys", they include mouse buttons, and
  - although called "mouse buttons", they double for touch input
    - (or at least the left mouse button counts as the first touch input; not sure about the others)
  - are you confused yet?
  - from FP/HXP, this is also Key!

input flow / propogation:
  - input events are setup in Window via addEventListener, accordingly to each target ("global level")
    - then handled by Scene via addSceneEventListener ("scene level")
    - then handled and simplified by Key
    - ...then optionally accessed by Interactive? ("Interactive level")
  - although you can directly access and hook into the global input events, you will likely want to use Key for keys, scene.mouseX and scene.mouseY for screen-level mouse/touch inputs, and Interactive for handling mouse/touch based on the game's scene Objects
  - note: can use Key to handle keyboard events from anywhere, even without Interactive! it is automatically initialized by App, so there is no need to do anything
  - Interactive provides a link between scene tree objects and input, figuring out which object should receive the input
    - imagine you have a 3d world on a tablet device, you will likely want the top-most camera-facing objects to capture input
  - Scene has getInteractable (among other things...) which figures out and fetches the top-most Interactable
  


object, and all of it's inherited classes:
  - think of these as components of an entity: transform, render, input, vector graphics, etc.
    - as in, something that provides a suite of vars 'n functions to help do something in particular: a library?
  - maybe can inherit Object to write your own components (?)
    - more likely though, all you need is to write some logical code alongside it (a "script" in Unity), often combined toegher into a single data structure called an "entity"
Object
  - base scene tree object
  - can have a parent Object and can have children Objects, like Flash api
  - provides a transform component (x, y, rotation), providing local to global coordinate helper functions too
Drawable
  - extends Object
  - ...provides a draw/render component (?? no clue)
Graphics
  - extends Drawable
  - provides a Flash-like vector drawing api component (lineStyle, moveTo/lineTo, fill/endFill, etc.)
Interactive
  - extends Object
  - provides an input capture handling component
Layers
  - extends Object
    - although this extends object for the sake of inheriting functionality, it's logically very confusing
  - provides a special container data structure tailored to the scene tree: an array of layers indicies
  - it provides ways to put/remove things where you want in the scene tree: under this object, above that layer, etc.,
  - although an optional feature, this is very very likely needed for nearly kind of every game


std.Math
  - sin, cos, abs, random, etc.
Math (hxd.Math)
  - clamp, lerp, etc., more game-related
h2d.col (collider)
  - contains most 2d geometry ds: Point, Bounds (rectangle), etc.
    - these ds provide most of the useful 2d math functionalities, not just for collisions
  - also a very confusing place to hide it...
hxd.Vector
  - 4 value vector
  - todo: i wasn't able to find a 2d vector...

snd (sound)
  - Manager.getInstance() can be used to handle all audio needs
  - the sound resource ds (hxd.res.sound) itself also contains a few helper functions: play(), stop(); that might be just enough for a small game or for quickly testing the sound file

res (resource)
  - used to load various files (resources, "assets") into the game: fonts, sounds, images, animations, data (castle db), etc.


  

-- (end of structure)



selected game examples:
https://github.com/ncannasse
  - TODO: glance through all of his ld games
  - https://github.com/ncannasse/ld40/blob/master/src/Game.hx
    - **the best game example i've seen, including the simplest entity system (an array)**

https://github.com/Yanrishatum/cherry-jam
  - a collection of a Heaps god's ld games
  - ld47 in particular has many good game framework ideas



selected "game bases":
https://github.com/jefvel/game-base/tree/master/src
  - **this looks like what would happen if i tried to make a complete game base**
  - i likely will use ds from this game base as a base for my own game base... yep, i'm based

https://github.com/deepnight/gameBase/tree/master/src
  - i feel like there's a lot of unneccary stuff specific to his games... I avoided using his game base because i felt it was better to stick with just core Heaps than to add another rather large layer on top of that, which itself might just depend on his own library (deepnightLibs)... For example his entity class is already quite large, with a ton of stuff i prolly don't need, at least not at first... but he made Dead Cells tho!!
  - having said that, he probably has some of the most useful in-production code regarding: gamepad controls (device input), 2d platformer controls (2d movement), porting (especially Nintendo Switch), cross-platform building and distributing, and a ton of other useful things

https://github.com/TerryCavanagh/terryheaps/tree/master/terryheaps
  - more "creative" framework style of coding, lol, but has a raw primitive beauty to it :)
  - because it's so simple, some of his ds can be used as primitive bases to start with (sound, mouse, graphics extensions, etc.), but, for the most part, it's all just janky game jam style get-shit-done type of code. Most of it does not scale well, if at all.



other:
https://github.com/HaxePunk/HaxePunk
  - still an amazing feat, and since it was in Haxe, can use nearly any code from it, especially the math/geometry ones
  - Vector2, utility classes, functions, there's a ton of stuff in there





trace is not logged in the console!
